# 尽量以 `const`、`enum`、`inline` 替换 `#define`
也可以换种说法， *尽可能使用编译器，而不是预处理器* 。因为 `#define` 实际上不会被编译器处理，这便是问题所在。比如当你写了如下代码：
```c++
#define ASPECT_RATIO 1.653
```
然而，编译器不会发现符号名称 `ASPECT_RATIO`，这是因为代码被编译之前，预处理器已经将它替换成了 `1.653`，这就导致 `ASPECT_RATIO` 不会被列入符号表。这会在调试程序的时候给你带来麻烦，因为错误的信息可能就在 `1.653`，而不是 `ASPECT_RATIO`。如果你没有在头文件写下 `ASPECT_RATIO`，你可能会花费大量时间来找到这处错误。这个问题也可能出现在符号调试器中，同样是因为该名称不在符号表中。

解决该问题的方法是用 `const` 替换 `#define`：
```c++
const double AspectRatio = 1.653; // 全部大写命名方式适用于宏，这里采用大驼峰法命名。
```

这样，`AspectRatio` 确实能被编译器发现，并且被列入符号表。此外，对于本例中的浮点数常量，使用 `const` 会比 `#define` 编译出更小的目标代码。这是因为，预处理器将 `ASPECT_RATIO` 替换为 `1.653` 会导致你的目标代码保留了多份 `1.653`。然而，使用 `const` 就只会有一份。

当我们要用 `const` 替换 `#define` 时，要考虑以下两种特殊情况：
1. 定义常量指针。
> 通常，常量的定义放在头文件中，以便不同的源文件能包含它，因而除了对指针所指内容声明为 `const` 之外，还要将指针声明为 `cosnt`。

如果要在头文件中定义了基于 `char*` 的字符串，考虑下述用例，你需要使用两次 `const`：
```c++
const char* const authorName = "Scott Meyers";
```
关于 `const` 结合指针的使用，参见 3。这里值得一提的是，`string` 比基于 `char*` 的字符串更方便使用，比如下述常量字符串的定义方式就更好（不需要使用两次 `const`）：
```c++
const std::string authorName("Scott Meyers");
```
2. 定义类的成员常量。
> 如果你要限制常量的作用域在类里面，那么你就需要将常量声明为该类的成员；如果你要确保常量只保留一份，你就需要声明它为静态成员。

观察下述用例：
```c++
class GamePlayer {
    private:
        static const int NumTurns = 5;  // 声明常量（声明并且初始化）
        int scores[NumTurns];           // 使用该常量
        ...
};
```

注意，这里的 `NumTurns` 是声明式，而非定义式。通常，C++ 要求在使用某变量时，你需要事先定义它，除非是整型（如：`int`, `char`, `bool`）。
+ 如果你不需要获取它的地址，你可以只声明而不定义。
+ 如果你需要获取它的地址，或者你的编译器不允许未定义而使用它，你可以单独写下如下定义：
```c++
const int GamePlayer::NumTurns; // 定义常量（这里不需要赋值初值，请继续往下看。）
```
你要把这行代码放在实现文件，而不是头文件。注意到，声明的时候该常量已经初始化，所以在定义的时候未赋予初值是允许的。

顺便一提，使用 `#define` 则无法定义类的常量，原因有二：
- 其一， `#define` 会无视作用域（除非你用 `#undef`）；
- 其二， `#define` 不提供封装性，也就是说不存在 _私有的_ `#define`。

旧版的编译器可能不支持上述语法，因为类的静态成员声明时初始化是非法的。更进一步来说，只允许类的整型常量在声明时赋初值。

如果上述代码不能通过编译，你需要将初值放在定义式，考虑下述用例：
```c++
class CostEstimate {
    private:
        static const double FudgeFactor;       // 声明静态整型常量；
        ...                                    // 位于头文件内
};

const double CostEstimate::FudgeFactor = 1.35; // 定义该常量；位于实现文件内
```

你几乎总会这样写。唯一的例外是上述 `GamePlayer::scores` 的声明（因为编译器在编译之前必须知道数组的大小），这时候你的编译器不允许静态成员声明时赋初值实际上就是愚蠢的做法了。当然，我们可以使用 `enum` 来解决这个问题。使用 `enum` 的好处是，它的值可以作为整型来使用，所以 `GamePlayer` 也可以改写成如下示例：
```c++
class GamePlayer {
    private:
        enum {NumTurns = 5};    // enum hack 使符号 NumTurns 表示 5
        int scores[NumTurns];   // 编译通过
        ...
};
```
值得你关注 **enum hack** 的两个理由：
1. **enum hack** 比起 `const` 表现得更像 `#define`。例如：`const` 可以获取常量的地址，而 `enum` 不能，`#define` 也不能。如果你不想其他人获取整型常量的指针或其引用，`enum` 会是很好的约束方式（更多讨论，参见 18）。当然，优秀的编译器不会为整型常量设定多余的存储空间（除非你创建了该对象的指针或其引用，或者它是一个愚蠢的编译器），而你也不想如此。如同 `#define`，`enum` 也不会导致非必要的内存分配。
2. **enum hack** 实用性强，许多代码都会使用它，所以你必须关注它。

实际上，**enum hack** 属于模板元编程（参见 48）的基本技术。

另外，常见的 `#define` 误用情况是用它来实现类似函数的宏，而实际并不会有调用函数的开销。

考虑下述宏的定义：
```c++
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
```

这样的宏定义存在太多缺陷，光想到它都会让人头疼。

无论何时你写下这种宏定义，你都要记得给每个参数加上括号，否则，你这样宏定义就会出问题。即使记得加上括号，定义看上去也是对的，也会有荒谬的事情发生，比如：
```c++
int a = 5, b = 0;
CALL_WITH_MAX(++a, b);              // a 自增两次
CALL_WITH_MAX(++a, b + 10);         // a 自增一次
```

在这里，调用 `f` 之前，`a` 的自增次数竟然取决于它和谁比较，何等荒谬！

幸运的是，你只要使用 `template` 的内联函数（参加 30）就可以获得宏定义带来的效率并且能表现出正确的函数行为，还能确保函数的类型安全，至此你就无需为上述荒谬的事情而头疼了，请看下述用例：
```c++
template<typename T>
inline void callWithMax(const T& a, const T& b){ 
    // 由于不知道 T 是什么，所以使用常量引用（参见 20）。
    f(a > b ? a : b);
}
```

这个模板能生成了整个函数族，每个函数有相同类型的两个对象，并且 `f` 作用到较大的那个对象。你无需为每个参数都要加上括号，也无需担心对象被作用多次。并且，因为 `callWithMax` 是真正的函数，它遵循作用域和访问规则。还有，你可以完美地在类内写出 `private` 的内联函数，而宏一般做不到。

最后，尽量多使用 `const`、`enum`、`inline`，这样我们对预处理器的需求就减少了（特别是 `#define`），但并非不需要预处理器。因为 `#include` 仍然是必要的，而 `#ifdef`/`#ifndef` 在控制编译方面也发挥着重要作用，所以还不到预处理器完全退役的时候，但你也应该尽量给它放假（尽量不使用它）。

# 牢记
+ 对于简单的常量定义，尽量用 `const` 或 `enum` 替换 `#define`；
+ 对于类似函数的宏，尽量用内联函数替换 `#define`。