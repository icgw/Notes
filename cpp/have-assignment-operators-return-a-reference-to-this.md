# 让赋值运算符返回 `*this` 的引用
你可以使用如下的链式赋值：
```c++
    int x, y, z;
    x = y = z = 15;  // 链式赋值
```
实际上，赋值是从右边的顺序依次进行的，即上述的链式赋值可以理解为：
```c++
    x = (y = (z = 15));
```
首先，`15` 先赋值给 `z`，然后将赋值的结果（即更新后的 `z`）赋值给 `y`，再然后将赋值的结果（即更新后的 `y`）赋值给 `x`。

要实现这样的效果只要将赋值操作的返回结果设置为左边变量的引用即可。当你在实现类的赋值运算 `operator=` 时，有如下约定：
```c++
class Widget {
public:
    ...
    Widget& operator=(const Widget& rhs) { // 返回类型为当前类的引用
        ...
        return *this;                      // 返回左边的对象
    }
    ...
};
```
这个约定可以运用到所有赋值运算，不仅仅是如上的标准格式。因此：
```c++
class Widget {
public:
    ...
    Widget& operator+=(const Widget& rhs) { // 可以运用到 +=, -=, *= 等等
        ...
        return *this;
    }

    Widget& operator=(int rhs) {            // 甚至对于不同参数类型也一样
        ...
        return *this;
    }
};
```
就是这一条唯一约定；你不遵守该约定代码也可以编译通过，然而，这条约定适用于所有内置类型，也包括所有标准库（参见 54）里的类型（例如：`string`、`vector`、`complex`、`tr1::shared_ptr` 等等）。你要是没有更好的理由，那么请遵守该约定。

# 牢记
+ 让赋值运算符返回 `*this` 的引用